<html>
<body>

<svg viewBox="0 0 900 1500">
    <defs>
        <pattern id="smallGrid" width="15px" height="15px" patternUnits="userSpaceOnUse">
            <path d="M 15 0 L 0 0 0 15" fill="none" stroke="gray" stroke-width="0.5" />
        </pattern>
        <pattern id="grid" width="75" height="75" patternUnits="userSpaceOnUse">
            <rect width="75" height="75" fill="white" /> <!-- fill="url(#smallGrid)" -->
            <path d="M 75 0 L 0 0 0 75" fill="none" stroke="blue" stroke-width="4" />
        </pattern>
    </defs>
    <rect x="0" y="0" width="100%" height="100%" id="gridParent" fill="white" /> <!-- fill="url(#grid)" -->
</svg>


<script>
const svg = document.querySelector('svg');
const bb = svg.getBBox();
const strokeWidth = 4;

//get viewBox and adjust it to avoid overflow caused by grid strokes
const [x, y, width, height] = [bb.x, bb.y, bb.width + strokeWidth / 2, bb.height + strokeWidth / 2];
svg.setAttribute('viewBox', [x, y, width, height].join(' '));
const cols = Math.floor((width - strokeWidth / 2) / 75);
const rows = Math.floor((height - strokeWidth / 2) / 75);

// add labels
addGridLabelsCoord(svg, cols, rows, width, height, strokeWidth);


function addGridLabelsCoord(svg, cols, rows, width = 1, height = 1, strokeWidth = 1) {
  // set initial y/x offset according to stroke width to avoid cropped outer strokes
  let offsetX = (width - strokeWidth / 2) / cols;
  let offsetY = (height - strokeWidth / 2) / rows;
  let currentRow = 1;
  let currentCol = 1;
  let shiftX = 0;
  let shiftY = 0;
  let cellCount = cols * rows;
  let nameSpace = 'http://www.w3.org/2000/svg';

  // loop through all columns
  for (let i = 0; i < cellCount; i++) {
    // if current index is divisible by columns â€“ move to next row
    if (i > 0 && i % (cols) === 0) {
      shiftX = 0;
      shiftY += offsetY;
      currentCol = 1;
      currentRow++;
    }

    let cellNumber = (currentRow-1) * cols + currentCol;


    // add new cell to output
    let rect = document.createElementNS(nameSpace, 'rect');
    rect.setAttribute('x', shiftX + strokeWidth);
    rect.setAttribute('y', shiftY + strokeWidth);
    rect.setAttribute('rx', offsetX/8);
    rect.setAttribute('ry', offsetY/8);
    rect.setAttribute('width', offsetX - 2*strokeWidth);
    rect.setAttribute('height', offsetY - 2*strokeWidth);
    rect.setAttribute('fill', 'white');
    rect.setAttribute('stroke', 'black');
    if (cellNumber > 2 && cellNumber % 2 == 0) {
      rect.setAttribute('fill', 'cyan');
    }
    if (cellNumber > 3 && cellNumber % 3 == 0) {
      rect.setAttribute('fill', 'yellow');
    }
    if (cellNumber > 5 && cellNumber % 5 == 0) {
      rect.setAttribute('fill', 'pink');
    }
    if (cellNumber > 7 && cellNumber % 7 == 0) {
      rect.setAttribute('fill', 'lightgreen');
    }
    if (cellNumber > 11 && cellNumber % 11 == 0) {
      rect.setAttribute('fill', 'plum');
    }
    if (cellNumber > 13 && cellNumber % 13 == 0) {
      rect.setAttribute('fill', 'wheat');
    }


    svg.appendChild(rect);


    let text = document.createElementNS(nameSpace, 'text');
    text.setAttribute('x', +(shiftX + offsetX / 2).toFixed(1));
    text.setAttribute('y', +(shiftY + offsetY / 2).toFixed(1));
    text.setAttribute('dominant-baseline', 'central');
    text.setAttribute('text-anchor', 'middle');
    text.textContent = cellNumber;
    svg.appendChild(text);



    // increment x offset for next column
    shiftX += offsetX;
    currentCol++;
  }
}
</script>

<!--

layer 1 is white with all numbers visible
layer 2 is clear with translucent red circles for multiples of 2 ( or cat-eye shapes )
layer 3 is clear with translucent yellow triangles for multiples of 3
layer 5 is clear with translucent blue pentagons for multiples of 5
layer 7 is clear with translucent green 7-stars for multiples of 7
layer 11 is clear with translucent orange 11-stars for multiples of 11
layer 13 is clear with translucent purple 13-stars for multiples of 13

  -->
